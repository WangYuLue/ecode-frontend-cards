<!-- promise 相关 -->

### 1、在异常处理中，如果 try 中 return 了， finally 中的代码还会不会执行？

参考下面的例子：

```js
function func() {
  try {
    console.log('try code')
    return 1;
  } catch (e) {
    console.log('error code')
  } finally {
    console.log('finally code');
  }
}

func()
```

上面会打印：

```js
'try code'
'finally code'
```

因为 **finally 会在控制转向外部代码前被执行**。

### 2、Promise 中 resolve 或 reject 后，后面的代码还会运行吗？

参考下面的例子，会不会打印 `after resolve`?

```js
new Promise((res, rej) => {
  setTimeout(() => {
    res('ok');
    console.log('after resolve')
  })
}).then(res => {
  console.log('settled:', res);
})
```

答案是 **会** ，`Promise` 中 `resolve` 或 `reject` 后，后面的代码会继续运行。

### 3、Promise 中， finally 后面的 then 会不会运行？

参考下面的例子，打印结果是什么?

```js
new Promise((resolve, reject) => {
  setTimeout(() => resolve("result"), 2000)
})
  .finally(() => console.log("run finally"))
  .then(result => console.log(result));
```

finally 后的 then 可以继续运行，上面代码运行结果是：

```bash
run finally
result
```

`finally()` 方法返回一个 `Promise`。 在 `promise` 结束时，无论结果是 `fulfilled` 或者是 `rejected`，都会执行指定的回调函数。这为在 `Promise` 是否成功完成后都需要执行的代码提供了一种方式。

参考链接：

[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally)

[Promise finally](https://zh.javascript.info/promise-basics#finally)

### 4、Promise：then 对比 catch

这两个代码片段是否相等？换句话说，对于任何处理程序，它们在任何情况下的行为都相同吗？

```js
promise.then(f1).catch(f2);

// 对比：

promise.then(f1, f2);
```

解答：

**不，它们不相等。**

不同之处在于，如果 `f1` 中出现 `error`，那么在这儿它会被 `.catch` 处理：

```js
promise
  .then(f1)
  .catch(f2);
```

……在这儿则不会：

```js
promise
  .then(f1, f2);
```

这是因为 `error` 是沿着链传递的，而在第二段代码中，`f1` 下面没有链。

换句话说，`.then` 将 `result/error` 传递给下一个 `.then/.catch`。所以在第一个例子中，在下面有一个 `catch`，而在第二个例子中并没有 `catch`，所以 `error` 未被处理。

参考链接：

[Promise：then 对比 catch](https://zh.javascript.info/task/then-vs-catch)

### 5、下面代码的运行结果是什么？

```js
new Promise((resolve, reject) => {
  resolve('success')
})
  .then(result => {
    console.log('1')
    throw 1;
  })
  .then(result => {
    console.log('2')
  })
  .catch(e => {
    console.log('12')
    throw 10;
  })
  .then(result => {
    console.log('3')
  })
  .then(result => {
    console.log('4')
  })
  .catch(e => {
    console.log('13')
  })
  .then(result => {
    console.log('5')
  })
  .then(result => {
    console.log('6')
  })
```

运行结果是：

```bash
1
12
13
5
6
```

通过上面的运行结果可以看出几点：

1、 Promise 周围有一个“隐式的 try..catch”。如果发生异常，异常不会被抛出，而是会被 rejection 捕获并被处理。

```js
new Promise((resolve, reject) => {
  throw new Error("Whoops!");
}).catch(console.log);

// 上面与下面的代码工作上完全相同

new Promise((resolve, reject) => {
  reject(new Error("Whoops!"));
}).catch(console.log);
```

2、`.then` 里出现异常后，接下来的 `.then` 都不会处理，直到遇到 `.catch`

3、`.catch` 被捕获到异常后，接下来的 `.then` 可以继续正常运行。

4、`.catch` 里也有可能会出现异常，这时候异常依然不会被直接抛出，而是看接下来会不会有另外的 `.catch` 来捕获到它

参考链接：
[使用 promise 进行错误处理](https://zh.javascript.info/promise-error-handling)

### 6、下面代码中，`.catch` 会被触发么？为什么？

代码如下：

```js
new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(e=>{
  console.log(e)
});
```

答案是：**它不会被触发：**

上面讲过，函数代码周围有个“隐式的 try..catch”，但那是针对所有的同步错误的。

而这里的错误并不是同步的，而是在稍后生成的。因此，`promise` 无法处理它。

另外，即使是 `try..catch`，也无法捕获异步的异常，例如：

```js
try {
  setTimeout(() => {
    throw 1;
  })
} catch (e) {
  console.log('error', e);
}
```

上面 `setTimeout` 中的异常不会被捕获到。

参考链接：

[setTimeout 中的错误](https://zh.javascript.info/task/error-async)

### 7、下面代码的运行结果是什么？

```js
let a = 0;
const b = async () => {
  a = a + await 10;
  console.log('2', a);
  a = (await 10) + a;
  console.log('3', a);
}
b();
a++;
console.log('1', a);
```

运行结果是：

```bash
1 1
2 10
3 20
```

这里可能会有的疑惑是：为什么 `async` 里打印的是 10 和 20，而不是 11 和 21 ，明明a++ 执行在前，里面的函数执行在后；

这是因为：

- 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为在 await 内部实现了 generators ，generators 会保留堆栈中东西，所以这时候 a = 0 被保存了下来；
- 因为 await 是异步操作，所以会先执行 console.log('1', a)；
- 这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 10；
- 然后后面就是常规执行代码了；

以下写法执行可以符合预期：

```js
let a = 0
const b = async () => {
  let c = await 10;
  a = a + c;
  console.log('2', a);
  a = (await 10) + a;
  console.log('3', a);
}
b();
a++;
console.log('1', a);
```

### 8、如何捕获全局未处理的 Promise 异常？

可以使用 `unhandledrejection` 监听事件来捕获处理的 Promise 异常

```js
window.addEventListener('unhandledrejection', function(event) {
  // 这个事件对象有两个特殊的属性：
  console.log(event.promise); // [object Promise] - 生成该全局 error 的 promise
  console.log(event.reason); // Error: Whoops! - 未处理的 error 对象
});

new Promise(function() {
  throw new Error("Whoops!");
}); // 没有用来处理 error 的 catch
```

需要注意的是，上面的代码如果直接贴在浏览器开发者工具上，那么 `unhandledrejection` 听事件可能不会生效，详细可以参考下面的链接 [unhandledrejection not working in chrome](https://stackoverflow.com/questions/40026381/unhandledrejection-not-working-in-chrome)。

另外，即使异常被处理了，DevTools 依然会有错误信息：

![](./images/04.png)

如果需要禁用此错误信息，需要在 unhandledrejection 事件处理函数中调用：

```js
event.preventDefault();
```

参考链接：
[使用 promise 进行错误处理](https://zh.javascript.info/promise-error-handling)

[unhandledrejection not working in chrome](https://stackoverflow.com/questions/40026381/unhandledrejection-not-working-in-chrome)

[unhandledrejection 处理没有显式捕获的 Promise 异常](https://github.com/justjavac/the-front-end-knowledge-you-may-not-know/issues/7)

### 9、JS 查询 URL 字符串中的参数

方法一：常规方法

```js
const parseQueryString = query => {
  const args = {};
  const qs = (query.length > 0 ? query.substring(1) : '');
  const items = qs.length ? qs.split('&') : [];
  for (let i = 0; i < items.length; i++) {
    const item = items[i].split('=');
    const name = decodeURIComponent(item[0]);
    const value = decodeURIComponent(item[1]);
    if (name.length) {
      args[name] = value;
    }
  }
  return args;
};
```

方法二：借助 `URLSearchParams` 对象

```js
const parseQueryString = query => {
  return Object.fromEntries([...new URLSearchParams(query)])
};
```

### 10、什么是 AST 抽象语法树

假如现在需要将 lisp 风格的函数调用转换为 C 风格，就会用到 AST：

```bash
               LISP                      C

2 + 2          (add 2 2)                 add(2, 2)
4 - 2          (subtract 4 2)            subtract(4, 2)
2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))
```

大多数编译器可以分成三个阶段：解析（Parsing），转换（Transformation）以及代码 生成（Code Generation）

1. *解析* 是将最初原始的代码转换为一种更加抽象的表示（译者注：即 **AST**）。

2. *转换* 将对这个抽象的表示做一些处理，让它能做到编译器期望它做到的事情。

3. *代码生成* 接收处理之后的代码表示，然后把它转换成新的代码。

具体谈谈解析：

解析一般来说会分成两个阶段：**词法分析**（Lexical Analysis）和**语法分析**（Syntactic Analysis）。

1. *词法分析* 接收原始代码，然后把它分割成一些被称为 Token 的东西，这个过程是在词法分析
器（Tokenizer或者Lexer）中完成的。

Token 是一个数组，由一些代码语句的碎片组成。它们可以是数字、标签、标点符号、运算符，
或者其它任何东西。

2. *语法分析* 接收之前生成的 Token，把它们转换成一种抽象的表示，这种抽象的表示描述了代
码语句中的每一个片段以及它们之间的关系。这被称为中间表示（intermediate representation）
或抽象语法树（Abstract Syntax Tree， 缩写为AST）

抽象语法树是一个嵌套程度很深的对象，用一种更容易处理的方式代表了代码本身，也能给我们
更多信息。

比如说对于下面这一行代码语句：

```js
(add 2(subtract 4 2))
```

它产生的 Token 看起来或许是这样的：

```js
[
  { type: 'paren', value: '(' },
  { type: 'name', value: 'add' },
  { type: 'number', value: '2' },
  { type: 'paren', value: '(' },
  { type: 'name', value: 'subtract' },
  { type: 'number', value: '4' },
  { type: 'number', value: '2' },
  { type: 'paren', value: ')' },
  { type: 'paren', value: ')' }
]
```

它的抽象语法树（AST）看起来或许是这样的：

```js
{
  type: 'Program',
  body: [{
    type: 'CallExpression',
    name: 'add',
    params: [{
      type: 'NumberLiteral',
      value: '2'
    }, {
      type: 'CallExpression',
      name: 'subtract',
      params: [{
        type: 'NumberLiteral',
        value: '4'
      }, {
        type: 'NumberLiteral',
        value: '2'
      }]
    }]
  }]
}
```

参考链接：

[the-super-tiny-compiler-cn](https://github.com/starkwang/the-super-tiny-compiler-cn/blob/master/super-tiny-compiler-chinese.js)

[AST 抽象语法树](https://segmentfault.com/a/1190000016231512)

[recast](https://github.com/benjamn/recast)
